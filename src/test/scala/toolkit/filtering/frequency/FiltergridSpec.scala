/*
 * (c) Copyright 2016 Hewlett Packard Enterprise Development LP
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package toolkit.filtering.frequency

import libcog._
import org.scalatest.FunSuite
import org.junit.runner.RunWith
import org.scalatest.junit.JUnitRunner

/** Test code. */
@RunWith(classOf[JUnitRunner])
class FiltergridSpec extends FunSuite {
  test("all") {
    // The matrices r, u1, u2 were generated by Kovesi's Matlab code by
    // calling filtergrid(8, 8)
    val r = Matrix( Array(
      Array(0f,      0.1250f, 0.2500f, 0.3750f, 0.5000f, 0.3750f, 0.2500f, 0.1250f),
      Array(0.1250f, 0.1768f, 0.2795f, 0.3953f, 0.5154f, 0.3953f, 0.2795f, 0.1768f),
      Array(0.2500f, 0.2795f, 0.3536f, 0.4507f, 0.5590f, 0.4507f, 0.3536f, 0.2795f),
      Array(0.3750f, 0.3953f, 0.4507f, 0.5303f, 0.6250f, 0.5303f, 0.4507f, 0.3953f),
      Array(0.5000f, 0.5154f, 0.5590f, 0.6250f, 0.7071f, 0.6250f, 0.5590f, 0.5154f),
      Array(0.3750f, 0.3953f, 0.4507f, 0.5303f, 0.6250f, 0.5303f, 0.4507f, 0.3953f),
      Array(0.2500f, 0.2795f, 0.3536f, 0.4507f, 0.5590f, 0.4507f, 0.3536f, 0.2795f),
      Array(0.1250f, 0.1768f, 0.2795f, 0.3953f, 0.5154f, 0.3953f, 0.2795f, 0.1768f)
    ))

    val u1 = Matrix( Array(
      Array(0f, 0.1250f, 0.2500f, 0.3750f,-0.5000f,-0.3750f,-0.2500f,-0.1250f),
      Array(0f, 0.1250f, 0.2500f, 0.3750f,-0.5000f,-0.3750f,-0.2500f,-0.1250f),
      Array(0f, 0.1250f, 0.2500f, 0.3750f,-0.5000f,-0.3750f,-0.2500f,-0.1250f),
      Array(0f, 0.1250f, 0.2500f, 0.3750f,-0.5000f,-0.3750f,-0.2500f,-0.1250f),
      Array(0f, 0.1250f, 0.2500f, 0.3750f,-0.5000f,-0.3750f,-0.2500f,-0.1250f),
      Array(0f, 0.1250f, 0.2500f, 0.3750f,-0.5000f,-0.3750f,-0.2500f,-0.1250f),
      Array(0f, 0.1250f, 0.2500f, 0.3750f,-0.5000f,-0.3750f,-0.2500f,-0.1250f),
      Array(0f, 0.1250f, 0.2500f, 0.3750f,-0.5000f,-0.3750f,-0.2500f,-0.1250f)
    ))


    val u2 = Matrix( Array(
      Array( 0f,      0f,      0f,      0f,      0f,      0f,      0f,      0f),
      Array( 0.1250f, 0.1250f, 0.1250f, 0.1250f, 0.1250f, 0.1250f, 0.1250f, 0.1250f),
      Array( 0.2500f, 0.2500f, 0.2500f, 0.2500f, 0.2500f, 0.2500f, 0.2500f, 0.2500f),
      Array( 0.3750f, 0.3750f, 0.3750f, 0.3750f, 0.3750f, 0.3750f, 0.3750f, 0.3750f),
      Array(-0.5000f,-0.5000f,-0.5000f,-0.5000f,-0.5000f,-0.5000f,-0.5000f,-0.5000f),
      Array(-0.3750f,-0.3750f,-0.3750f,-0.3750f,-0.3750f,-0.3750f,-0.3750f,-0.3750f),
      Array(-0.2500f,-0.2500f,-0.2500f,-0.2500f,-0.2500f,-0.2500f,-0.2500f,-0.2500f),
      Array(-0.1250f,-0.1250f,-0.1250f,-0.1250f,-0.1250f,-0.1250f,-0.1250f,-0.1250f)
    ))

    val (myR, myU1, myU2) = Filtergrid(8, 8)

    // Because we have only 4 decimals of precision in the Matlab code, we
    // must truncate our result to 4 decimals.
    def truncate(matrix: Matrix): Matrix = {
      matrix.map(x => (10000 * x).toInt.toFloat / 10000)
    }

    require(truncate(r) ~== truncate(myR))
    require(truncate(u1) ~== truncate(myU1))
    require(truncate(u2) ~== truncate(myU2))
  }
}